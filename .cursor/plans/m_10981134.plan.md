---
name: M
overview: Umfassende Neugestaltung der MindSync-Architektur zur Erreichung klinisch relevanter Brainwave-Entrainment-Qualität durch präzise Rechteckwellen-Stimulation, Master-Clock-Synchronisation und intelligente Audio-Analyse.
todos: []
---

# MindSync NeuroSync-Architektur: Implementierungsplan

## Analyse der aktuellen Situation

Die bestehende Codebasis hat bereits gute Grundlagen, aber basierend auf den Forschungsdokumenten fehlen kritische Optimierungen für effektives Neural Entrainment:

**Bereits implementiert:**

- Thermisches Management via `ThermalManager`
- Frequenzabhängige Duty Cycles im `FlashlightController`
- Präzise Audio-Zeit via `preciseAudioTime`
- Audio-Latenz-Offset für Bluetooth-Kompensation
- Core Haptics Integration

**Kritische Defizite:**

- CADisplayLink-basiertes Timing (UI-abhängig, ungenaues Frequenz-Aliasing)
- Keine Kamera-Pre-Warming (Cold-Start-Latenz)
- Cinematic Mode nur RMS-basiert (kein Spectral Flux, kein Lookahead)
- Keine dynamische Bluetooth-Latenz-Messung
- Haptik nicht transient (kontinuierliche Vibration statt kurze Klicks)

---

## Phase 1: Master-Clock und Timing-Präzision (Priorität: KRITISCH)

### 1.1 Migration von CADisplayLink zu DispatchSourceTimer

**Problem:** CADisplayLink ist an die Display-Framerate gebunden (60/120 Hz), was Aliasing-Probleme bei Entrainment-Frequenzen verursacht (z.B. 14 Hz ist nicht exakt darstellbar bei 60 Hz Display).

**Lösung:** Dedizierte `DispatchSourceTimer` auf hochprioritärer Hintergrund-Queue.

**Dateien:**

- [`MindSync/Core/Light/BaseLightController.swift`](MindSync/Core/Light/BaseLightController.swift) - Timer-Migration
- [`MindSync/Core/Light/FlashlightController.swift`](MindSync/Core/Light/FlashlightController.swift) - Anpassung
- [`MindSync/Core/Light/ScreenController.swift`](MindSync/Core/Light/ScreenController.swift) - Anpassung
- [`MindSync/Core/Vibration/VibrationController.swift`](MindSync/Core/Vibration/VibrationController.swift) - Timer-Migration

**Implementierung:**

```swift
// Neuer Timer in BaseLightController
private var precisionTimer: DispatchSourceTimer?
private let timerQueue = DispatchQueue(label: "com.mindsync.entrainment", qos: .userInteractive)

func setupPrecisionTimer(intervalNs: UInt64) {
    precisionTimer = DispatchSource.makeTimerSource(flags: .strict, queue: timerQueue)
    precisionTimer?.schedule(deadline: .now(), repeating: .nanoseconds(Int(intervalNs)))
    precisionTimer?.setEventHandler { [weak self] in
        DispatchQueue.main.async { self?.updateLight() }
    }
    precisionTimer?.resume()
}
```

### 1.2 Audio-Thread als Master-Clock

**Erweiterung:** Nutze `AVAudioSourceNode` Render-Callback als ultimative Zeitreferenz.

**Dateien:**

- [`MindSync/Core/Audio/IsochronicAudioService.swift`](MindSync/Core/Audio/IsochronicAudioService.swift) - Master-Clock-Export
- Neue Datei: `MindSync/Core/Sync/MasterClock.swift`

---

## Phase 2: Stroboskop-Engine Optimierung (Priorität: HOCH)

### 2.1 Kamera Pre-Warming

**Problem:** 30-Sekunden-Verzögerung beim Session-Start durch Kamera-Kaltstart.

**Lösung:** AVCaptureSession beim App-Start initialisieren und im "Standby" halten.

**Dateien:**

- [`MindSync/Core/Light/FlashlightController.swift`](MindSync/Core/Light/FlashlightController.swift)
- [`MindSync/Services/ServiceContainer.swift`](MindSync/Services/ServiceContainer.swift) - Frühe Initialisierung

**Änderungen:**

```swift
// FlashlightController - Neue Methode
func prewarm() async throws {
    guard let device = device, device.hasTorch else { return }
    try device.lockForConfiguration()
    // Kurzer Blitz um Hardware zu aktivieren
    try device.setTorchModeOn(level: 0.01)
    try await Task.sleep(nanoseconds: 50_000_000) // 50ms
    device.torchMode = .off
    device.unlockForConfiguration()
}
```

### 2.2 Aggressivere Duty Cycles für härtere Rechteckwellen

**Problem:** Bei hohen Frequenzen erreicht die LED nicht volle Helligkeit vor dem Ausschalten.

**Lösung:** Noch kürzere AN-Phasen mit höherer Intensität.

**Datei:** [`MindSync/Core/Light/FlashlightController.swift`](MindSync/Core/Light/FlashlightController.swift)

**Änderungen:**

```swift
private func calculateDutyCycle(for frequency: Double) -> Double {
    if frequency > 30.0 {
        return 0.15  // 15% für Gamma >30Hz - extrem kurze Blitze
    } else if frequency > 20.0 {
        return 0.20  // 20% für Gamma 20-30Hz
    } else if frequency > 10.0 {
        return 0.30  // 30% für Alpha - vorher 35%
    }
    return 0.45  // 45% für Theta - vorher 50%
}
```

### 2.3 Thermisches Management Verbesserung

**Problem:** Erst bei `.serious` wird gedrosselt, bei `.fair` passiert nichts.

**Lösung:** Proaktive Reduktion auch bei `.fair`.

**Datei:** [`MindSync/Core/Safety/ThermalManager.swift`](MindSync/Core/Safety/ThermalManager.swift)

**Änderungen:**

```swift
var maxFlashlightIntensity: Float {
    switch currentState {
    case .nominal:
        return 1.0
    case .fair:
        return 0.8  // NEU: Proaktive Reduktion
    case .serious:
        return 0.5
    case .critical:
        return 0.0
    @unknown default:
        return 0.5
    }
}

var recommendedDutyCycleMultiplier: Double {
    switch currentState {
    case .nominal: return 1.0
    case .fair: return 0.85    // NEU
    case .serious: return 0.6
    case .critical: return 0.0
    @unknown default: return 0.7
    }
}
```

---

## Phase 3: Cinematic Mode Intelligence (Priorität: HOCH)

### 3.1 Echtzeit Spectral Flux Analyse

**Problem:** Aktueller `AudioEnergyTracker` nutzt nur RMS - bei "Wall of Sound" (z.B. Hans Zimmer) leuchtet das Licht konstant.

**Lösung:** Spectral Flux Detection mit Bass-Isolation.

**Neue Datei:** `MindSync/Core/Audio/SpectralFluxDetector.swift`

```swift
final class SpectralFluxDetector {
    private let fftSetup: FFTSetup
    private var previousMagnitude: [Float] = []
    private let bassRange = 0..<32  // 0-1400 Hz bei 44.1kHz
    
    /// Berechnet Spectral Flux für Bass-Bereich
    func calculateBassFlux(from buffer: AVAudioPCMBuffer) -> Float {
        // FFT durchführen
        let magnitude = performFFT(buffer)
        
        // Nur positive Änderungen im Bass-Bereich summieren
        var flux: Float = 0
        for i in bassRange {
            let diff = magnitude[i] - previousMagnitude[i]
            if diff > 0 { flux += diff }
        }
        
        previousMagnitude = magnitude
        return flux
    }
}
```

### 3.2 Lookahead-Buffer für proaktive Beat-Erkennung

**Problem:** Reaktive Erkennung erzeugt Latenz - Licht kommt nach dem Beat.

**Lösung:** Audio 300-500ms voraus analysieren.

**Neue Datei:** `MindSync/Core/Audio/LookaheadBeatDetector.swift`

**Integration in:** [`MindSync/Features/Session/SessionViewModel.swift`](MindSync/Features/Session/SessionViewModel.swift)

### 3.3 Garantiertes Flackern mit Cooldown

**Problem:** Bei lauter Musik ist das Licht dauerhaft an.

**Lösung:** Erzwungene Minimum-Off-Zeit nach jedem Blitz.

**Datei:** [`MindSync/Core/Entrainment/EntrainmentEngine.swift`](MindSync/Core/Entrainment/EntrainmentEngine.swift)

```swift
static func calculateCinematicIntensity(...) -> Float {
    // ... bestehende Berechnung ...
    
    // NEU: Erzwungenes Flackern
    let minOffTime: TimeInterval = 0.08  // 80ms Minimum-Pause
    let cyclePhase = currentTime.truncatingRemainder(dividingBy: 1.0 / 8.0) // 8 Hz Basis
    if cyclePhase < minOffTime {
        return 0.0  // Erzwungene Dunkelphase
    }
    
    return output
}
```

---

## Phase 4: Bluetooth-Latenz-Kompensation (Priorität: MITTEL)

### 4.1 Dynamische Latenz-Messung

**Problem:** `outputLatency` wird nur einmal gelesen, ändert sich aber dynamisch.

**Lösung:** Kontinuierliche Überwachung der Audio-Session-Latenz.

**Neue Datei:** `MindSync/Core/Sync/BluetoothLatencyMonitor.swift`

```swift
final class BluetoothLatencyMonitor {
    @Published var currentLatency: TimeInterval = 0
    
    func startMonitoring() {
        Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            let session = AVAudioSession.sharedInstance()
            self?.currentLatency = session.outputLatency + session.inputLatency
        }
    }
}
```

### 4.2 Circular Buffer für Licht-Verzögerung

**Problem:** Licht muss verzögert werden um mit Bluetooth-Audio synchron zu sein.

**Lösung:** Ring-Buffer für Licht-Events.

**Neue Datei:** `MindSync/Core/Sync/LightEventBuffer.swift`

---

## Phase 5: Transiente Haptik (Priorität: MITTEL)

### 5.1 Kurze Klicks statt kontinuierlicher Vibration

**Problem:** Aktuelle Implementierung nutzt `hapticContinuous` - fühlt sich diffus an.

**Lösung:** `hapticTransient` Events für jeden Beat.

**Datei:** [`MindSync/Core/Vibration/VibrationController.swift`](MindSync/Core/Vibration/VibrationController.swift)

```swift
private func createTransientPattern(intensity: Float) {
    let event = CHHapticEvent(
        eventType: .hapticTransient,  // Statt .hapticContinuous
        parameters: [
            CHHapticEventParameter(parameterID: .hapticIntensity, value: intensity),
            CHHapticEventParameter(parameterID: .hapticSharpness, value: 0.8)
        ],
        relativeTime: 0,
        duration: 0.02  // 20ms Impuls
    )
    // ...
}
```

### 5.2 AHAP-Pattern-Unterstützung

**Neue Datei:** `MindSync/Core/Vibration/HapticPatternGenerator.swift`

---

## Phase 6: UI/UX Verbesserungen (Priorität: NIEDRIG)

### 6.1 Kalibrierungs-UI für Audio-Latenz

**Problem:** Nutzer können Bluetooth-Latenz nicht manuell anpassen.

**Lösung:** Slider in Einstellungen mit Live-Test.

**Datei:** [`MindSync/Features/Settings/SettingsView.swift`](MindSync/Features/Settings/SettingsView.swift)

### 6.2 Echtzeit-Frequenz-Anzeige

**Bereits implementiert:** `currentFrequency` in SessionViewModel

---

## Zusammenfassung: Neue Dateien

| Datei | Beschreibung |

|-------|--------------|

| `MindSync/Core/Sync/MasterClock.swift` | Zentrale Zeitbasis für alle Subsysteme |

| `MindSync/Core/Sync/BluetoothLatencyMonitor.swift` | Dynamische Bluetooth-Latenz-Überwachung |

| `MindSync/Core/Sync/LightEventBuffer.swift` | Circular Buffer für Licht-Synchronisation |

| `MindSync/Core/Audio/SpectralFluxDetector.swift` | Echtzeit Spectral Flux mit Bass-Isolation |

| `MindSync/Core/Audio/LookaheadBeatDetector.swift` | Proaktive Beat-Erkennung mit Vorausschau |

| `MindSync/Core/Vibration/HapticPatternGenerator.swift` | AHAP-Pattern-Generator |

---

## Implementierungs-Reihenfolge

Die Phasen sollten in dieser Reihenfolge implementiert werden, da sie aufeinander aufbauen:

1. **Phase 1** (Master-Clock) - Grundlage für alle anderen Verbesserungen
2. **Phase 2** (Stroboskop-Engine) - Kritisch für SSVEP-Wirksamkeit
3. **Phase 3** (Cinematic Mode) - Wichtigstes Nutzer-Feature
4. **Phase 4** (Bluetooth-Latenz) - Notwendig für Kopfhörer-Nutzer
5. **Phase 5** (Haptik) - Nice-to-have Verbesserung
6. **Phase 6** (UI/UX) - Finale Politur